// ============================================================================
//   Author:  Ken Kumagai,Yanjie Shi, Kenji Uchida
//   Date:  10/01/2018
//   File: Lexer.cpp
//   Description: The following demonstrates the implementation of
//     Lexer using a table driven Finite State Machine.
// ============================================================================

#include <iostream>
#include <cstdlib>
#include <cctype>
#include <string>
#include <vector>
#include <fstream>
#include <stack>
using namespace std;

//global array size
const int ARRSEP = 9;
const int ARRKEYW = 11;

//global stack frame;
stack<char> sepMatch;

// global token state array
// idenState[0] = first identifier tester
// idenState[1] = test for 2nd identifier
// idenState[2] = for all identifiers
bool idenState[3] = { true,false,false };

//comment[0] switch for comment;
bool comment[1] = { false };

//opState[0] tests if first operator was an assignment
bool opState[1] = { false };

// if triggered statement breaks syntax
bool invalid[1] = { false };
bool sepstate[2];

//keywords
bool fun[99] = {false,false,false,false,false,false,false};

//body
bool body[1] = { false };

//expression
bool expression[1] = {false};

//integer considered identifier
bool intIsID[1] = { false };

//checks main function
bool mainTest[1] = { false };

//checks if loop statement
bool loops[3] = { false,false,false };

//checks for completion
bool complete[1] = { true };

enum FSM_TRANSITIONS
{
	REJECT = 0,
	INTEGER,
	REAL,
	OPERATOR,
	IDENTIFIER,
	UNKNOWN,
	SPACE,
	KEYWORD,
	BOOL,
	SEPARATOR
};

//KEYWORDS
string keywords[ARRKEYW] = { "int","if","else","endif","while","return","get","put"
,"boolean","function","real" };
string bools[2] = { "true","false" };
char separator[ARRSEP] = { '(',')','{','}','[',']',';', ':',',' };

/*                           integer,    real,    operator,   identifier, unknown, space,  keyword, bool,   separator*/
int stateTable[][10] = { {0,  INTEGER,    REAL,    OPERATOR,   IDENTIFIER, UNKNOWN, SPACE,  KEYWORD, BOOL,   SEPARATOR},
/* STATE 1 */   {INTEGER,    INTEGER,    REAL,    REJECT,     REJECT,     REJECT,  REJECT, REJECT,  REJECT, REJECT},
/* STATE 2 */   {REAL,       REAL,       UNKNOWN, REJECT,     REJECT,     REJECT,  REJECT, REJECT,  REJECT, REJECT},
/* STATE 3 */   {OPERATOR,   REJECT,     REJECT,  REJECT,     IDENTIFIER, REJECT,  REJECT, REJECT,  REJECT, REJECT},
/* STATE 4 */   {IDENTIFIER, IDENTIFIER, REJECT,  IDENTIFIER, IDENTIFIER, REJECT,  REJECT, REJECT,  REJECT, REJECT},
/* STATE 5 */   {UNKNOWN,    UNKNOWN,    UNKNOWN, UNKNOWN,    UNKNOWN,    UNKNOWN, REJECT, REJECT,  REJECT, REJECT},
/* STATE 6 */   {SPACE,      REJECT,     REJECT,  REJECT,     REJECT,     REJECT,  REJECT, REJECT,  REJECT, REJECT},
/* STATE 7 */   {KEYWORD,    KEYWORD,    REJECT,  KEYWORD,    KEYWORD,    REJECT,  REJECT, KEYWORD, REJECT, REJECT},
/* STATE 8 */   {BOOL,       REJECT,     REJECT,  REJECT,     REJECT,     REJECT,  REJECT, REJECT,  BOOL,   REJECT},
/* STATE 9 */   {SEPARATOR,  REJECT,     REJECT,  REJECT,     REJECT,     REJECT,  REJECT, REJECT,  REJECT, REJECT}
};

struct TokenType
{
	string token;
	int lexeme;
	string lexemeName;
};

vector<TokenType> Lexer(string expression);
int Get_FSM_Col(char currentChar);
string GetLexemeName(int lexeme); 
void parser(vector<TokenType> toks, int pos,ofstream& file);

int main()
{
	ifstream infile;
	ofstream outfile ("new.txt");
	string fileName = "";
	string expression = "";
	vector<TokenType> tokens;
	int line = 1;
	cout << "Please enter the name of the file: ";
	getline(cin, fileName);

	infile.open(fileName.c_str());

	if (infile.fail())
	{
		cout << "n** ERROR - the file ""<<fileName<<"" cannot be found!";
		system("pause");
		exit(1);
	}

	outfile << "Token					Lexeme" << endl;
	outfile << "_______________________________________________" << endl;
	while (getline(infile, expression))
	{
		
		tokens = Lexer(expression);
		
		for (unsigned i = 0; i < tokens.size(); ++i)
		{
			outfile << tokens[i].lexemeName << "					"
				<< tokens[i].token << endl;
			parser(tokens,i,outfile);
			if (invalid[0])
			{
				outfile << "ERROR at LINE " << line <<  ".\n";
			}
			outfile << '\n';
		}
		line++;
	}

	infile.close();
	outfile.close();
	system("pause");
	return 0;
}

/**
* FUNCTION: Lexer
* USE: Parses the "expression" string using the Finite State Machine to
*     isolate each individual token and lexeme name in the expression.
* param expression - A std::string containing text.
* return - Returns a vector containing the tokens found in the string
*/
vector<TokenType> Lexer(string expression)
{
	TokenType access;
	vector<TokenType> tokens;
	char currentChar = ' ';
	int col = REJECT;
	int currentState = REJECT;
	int prevState = REJECT;
	string currentToken = "";

	for (unsigned x = 0; x < expression.length();)
	{
		currentChar = expression[x];

		col = Get_FSM_Col(currentChar);

		currentState = stateTable[currentState][col];

		if (currentState == REJECT)
		{
			if (prevState != SPACE)
			{
				for (int i = 0; i < ARRKEYW; ++i)
				{
					if (currentToken == keywords[i])
					{
						prevState = KEYWORD;
					}
				}
				for (int i = 0; i < 2; ++i)
				{
					if (currentToken == bools[i])
					{
						prevState = BOOL;
					}
				}
				access.token = currentToken;
				access.lexeme = prevState;
				access.lexemeName = GetLexemeName(access.lexeme);
				tokens.push_back(access);
			}
			currentToken = "";
		}
		else
		{
			currentToken += currentChar;
			++x;
		}
		prevState = currentState;

	}
	if (currentState != SPACE && currentToken != "")
	{
		access.token = currentToken;
		access.lexeme = currentState;
		access.lexemeName = GetLexemeName(access.lexeme);
		tokens.push_back(access);
	}
	return tokens;
}

/**
* FUNCTION: Get_FSM_Col
* USE: Determines the state of the type of character being examined.
* param currentChar - A character.
* return - Returns the state of the type of character being examined.
*/
int Get_FSM_Col(char currentChar)
{
	// check for whitespace
	if (isspace(currentChar))
	{
		return SPACE;
	}

	// check for integer numbers
	else if (isdigit(currentChar))
	{
		return INTEGER;
	}

	// check for real numbers
	else if (currentChar == '.')
	{
		return REAL;
	}

	// check for characters
	else if (isalpha(currentChar))
	{
		return IDENTIFIER;
	}

	// check for operators and separators
	else if (ispunct(currentChar))
	{
		for (int i = 0; i < ARRSEP; ++i)
		{
			if (currentChar == separator[i])
			{
				return SEPARATOR;
			}
		}
		return OPERATOR;
	}
	return UNKNOWN;
}

/**
* FUNCTION: GetLexemeName
* USE: Returns the string equivalent of an integer lexeme token type.
* param lexeme - An integer lexeme token type.
* return - An std::string string representing the name of the integer
*        lexeme token type.
*/
string GetLexemeName(int lexeme)
{
	switch (lexeme)
	{
	case INTEGER:
		return "INTEGER";
		break;
	case REAL:
		return "REAL  ";
		break;
	case OPERATOR:
		return "OPERATOR";
		break;
	case IDENTIFIER:
		return "IDENTIFIER";
		break;
	case UNKNOWN:
		return "UNKNOWN";
		break;
	case SPACE:
		return "SPACE";
		break;
	case KEYWORD:
		return "KEYWORD";
		break;
	case BOOL:
		return "BOOL";
		break;
	case SEPARATOR:
		return "SEPARATOR";
		break;
	default:
		return "ERROR";
		break;
	}
}
void parser(vector<TokenType> toks,int pos,ofstream& file)
{
	char tokChar;
	string lexName;
	string tokName;
	TokenType someToken;
	someToken=toks.at(pos);
	lexName = someToken.lexemeName;
	tokName = someToken.token;
	tokChar = tokName[0];
	if (comment[0] == true)
	{
		if (tokChar == '!')
			comment[0] = false;
	}
	else if (invalid[0] == true)
	{
		if (tokChar == ';')
			invalid[0] = false;
	}
	else
		{
		if ((lexName == "KEYWORD") && (complete[0]))
		{
			if (tokName == "function")
			{
				file << "<Function> -> <Identifier> [ <Opt Parameter List>] <Opt Declaration List> <Body>\n";
				fun[0] = true;
				complete[0] = false;
			}
			if (tokName == "int")
			{
				if (fun[4])
				{
					file << "<Parameter> -> <Parameter> || ]\n";
					fun[4] = false;
					fun[5] = true;
				}

			}
			if (tokName == "boolean")
			{
				if (fun[3])
				{
					file << "<Parameter> -> <Parameter> || ]\n";
					fun[4] = true;
					fun[3] = false;
				}
			}
			if (tokName == "real")
			{
				if (fun[3])
				{
					file << "<Parameter> -> <Parameter> || ]\n";
					fun[4] = true;
					fun[3] = false;
				}
			}
			if (tokName == "return")
			{
				opState[0] = true;
				idenState[1] = true;
				file << "return -> <Expression>\n";
				complete[0] = false;
			}
			if (tokName == "while")
			{
				loops[0] = true;
				complete[0] = false;
			}
			if (tokName == "get")
			{
				idenState[1] = true;
			}
		}
			
		if ((lexName == "IDENTIFIER")||(intIsID[0]==true))
		{
			//function is triggered
			if (fun[0])
			{
				file << "<Identifier> -> [<Opt Paramter List>] <Opt Declartion List>\n";
				fun[1] = true;
				fun[0] = false;
			}
			else if (fun[2])
			{
				file << "<Identifier> -> :<Qualifier>]";
				fun[2] = false;
				fun[3] = true;
			}
			else
			{
				if (idenState[0] == true)
				{
					file << "<Statement> -> <Assign>\n";
					file << "<Assign> -> <Identifier> = <Expression>;\n";
					complete[0] = false;
					idenState[0] = false;
					idenState[1] = true;
				}
				else if (idenState[1] == true)
				{
					file << "<Expression> -> <Term> <Expression Prime>\n";
					idenState[1] = false;
					idenState[2] = true;
					complete[0] = false;
				}
				if (idenState[2] == true)
				{
					file << "<Term> -> <Factor> <Term Prime>\n";
					file << "<Factor> -> <Identifier>\n";
				}
			}
		}
		if (lexName == "OPERATOR")
		{
			if (tokChar == '=')
			{
				opState[0] = true;
			}
			else if ((opState[0] == true) && (tokChar == '+'))
			{
				file << "<Term Prime> -> E\n";
				file << "<Expression Prime> -> + <Term><Expression Prime>\n";
			}
			else if ((opState[0] == true) && (tokChar == '-'))
			{
				file << "<Term Prime> -> E\n";
				file << "<Expression Prime> -> - <Term><Expression Prime>\n";
			}
			else if ((opState[0] == true) && (tokChar == '*'))
			{
				file << "<Factor Prime> -> E\n";
				file << "< Term Prime> -> * <Factor><Term Prime>\n";
			}
			else if ((opState[0] == true) && (tokChar == '/'))
			{
				file << "<Factor Prime> -> E\n";
				file << "< Term Prime> -> / <Factor><Term Prime>\n";
			}
			else if ((opState[0] == true) && (tokChar == '%'))
			{
				file << "<Factor Prime> -> E\n";
				file << "< Term Prime> -> % <Factor><Term Prime>\n";
			}
			else if (tokChar == '<')
			{
				file << "<Factor Prime> -> E\n";
				file << "< Term Prime> -> < <Factor><Term Prime>\n";
			}
			else if (tokChar == '>')
			{
				file << "<Factor Prime> -> E\n";
				file << "< Term Prime> -> > <Factor><Term Prime>\n";
			}
			else if (tokChar == '!')
			{
				if (comment[0] == true)
				{
					comment[0] = false;
					sepMatch.pop();
					complete[0] = true;
				}
				else
				{
					comment[0] = true;
					sepMatch.push('!');
					complete[0] = false;
				}
				file << "comment";
			}
			else if (tokChar == '%')
			{
				if (mainTest[0])
				{
					file << "<main> -> <opt Declaration List> <Statement List>\n";
				}
				else
				{
					mainTest[0] = true;
				}
			}
			else
			{
				file << "Invalid Input!\n";
				invalid[0] = true;
			}
		}
		if (lexName == "SEPARATOR")
		{
			if (tokChar == ';')
			{
				file << "<Term Prime> -> E\n";
				file << "<Expression Prime> -> E\n";
				idenState[0] = true;
				idenState[1] = false;
				idenState[2] = false;
				opState[0] = false;
				invalid[0] = false;
				complete[0] = true;
			}
			if (tokChar == '[')
			{
				if (pos == 0)
				{
					invalid[0] = true;
				}
				else
				{
					TokenType thisToken;
					thisToken = toks.at(pos - 1);
					string thisLexeme;
					thisLexeme = thisToken.lexemeName;
					if (thisLexeme == "IDENTIFIER")
					{
						sepMatch.push('[');
						file << "<Parameter>  -> <Identifier> : <Qualifier> ]\n";
						fun[2] = true;
					}
				}
			}
			if (tokChar == ']')
			{
				TokenType thisToken;
				thisToken = toks.at(pos - 1);
				string thisLexeme;
				thisLexeme = thisToken.lexemeName;
				if ((thisLexeme == "KEYWORD") || (thisLexeme == "SEPARATOR"))
				{
					char thisChar = sepMatch.top();
					sepMatch.pop();
					if (thisChar == '[')
					{
						file << "<Parameter List> -> <Opt Declaration> <Body>\n";
						body[0] = true;
					}
				}
			}
			if (tokChar == '{')
			{
				if (loops[2])
				{
					sepMatch.push('{');
					file << "<Declaration> -> <Body> }\n";
				}
				else if (!body[0])
				{
					invalid[0] = true;
				}
				else
				{					
					sepMatch.push('{');
					file << "<Declaration> -> <Body> }\n";
					complete[0] = true;
				}
			}
			if (tokChar == '}')
			{
				TokenType thisToken;
				thisToken = toks.at(pos);
				string thisLexeme;
				thisLexeme = thisToken.lexemeName;

				char thisChar = sepMatch.top();
				sepMatch.pop();
				if (thisChar == '{')
				{
					file << "<Declaration>\n";
					body[0] = false;

				}
				else
				{
					invalid[0] = true;
				}
			}
			if (tokChar == '(')
			{
				if (pos == 0)
				{
					invalid[0] = true;
				}
				else
				{
					TokenType thisToken;
					thisToken = toks.at(pos - 1);
					string thisLexeme;
					thisLexeme = thisToken.lexemeName;
					if (loops[0] == true)
					{
						loops[0] = false;
						loops[1] = true;
					}
					if ((thisLexeme == "IDENTIFIER") || (thisLexeme == "SEPARATOR")||(thisLexeme=="KEYWORD")||(thisLexeme == "OPERATOR"))
					{
						sepMatch.push('(');
						file << "<Parameter> -> );\n";
						idenState[0] = false;
						idenState[1] = true;
					}
				}
			}
			if (tokChar == ')')
			{
				TokenType thisToken;
				thisToken = toks.at(pos);
				string thisLexeme;
				thisLexeme = thisToken.lexemeName;
				if (loops[1] == true)
				{
					loops[1] = false;
					loops[2] = true;
					idenState[0] = true;
					idenState[1] = false;
					idenState[2] = false;
					opState[0] = false;
					invalid[0] = false;
				}
				if (thisLexeme == "SEPARATOR")
				{
					char thisChar = sepMatch.top();
					sepMatch.pop();
					if (thisChar == '(')
						file << "<Parameter> -> ;\n";
				}
			}
			if (tokChar == ':')
			{
				if (fun[3])
				{
					fun[4] = true;
				}
			}
			if (tokChar == ',')
			{

			}
		}
	}
}
